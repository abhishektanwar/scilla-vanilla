(* HelloWorld contract *)

import ListUtils

(***************************************************)
(*               Associated library                *)
(***************************************************)
library HelloWorld

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let le_int =
  fun (a : Uint128) => fun(b : Uint128) =>
  let x = builtin lt a b in
  match x with 
    True => True
    False =>
    let y = builtin eq a b in
    match y with
      True => True
      False +> False
    end
  end    

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract ERC223Token
(totalSupply:Uint128)


field name : String = ""
field symbol : String = ""
field decimals : Uint128 = ""
field totalSupply : Uint128 =  
field balances : Map ByStr20 Uint128 = 
  let m = Emp ByStr20 Uint128 in
  builtin put m Owner totalSupply
  
field allowance : Map ByStr32 (Map ByStr20 Uint128) = Emp Bystr32 (Map ByStr20 Uint128)



transition ERC223Token(initialSupply : Uint128 , tokenName : String , decimalUnits : Uint128 , tokenSymbok : String)
  bl <- balances;
  bal = builtin put bl _sender totalSupply;
  balances := bal
  
  name := tokenName;
  decimals := decimalUnits;
  symbol := tokenSymbol;
  
  (*emit transfer*)
  
transition balanceOf(tokenOwner : ByStr20)
  bl <- balances;
  val = builtin get bl tokenOwner;
  match val with
  | Some v =>
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; bal : v };
    msgs = one_msg msg;
    send msgs
  | None =>
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; bal : Uint128 0 };
    msgs = one_msg msg;
    send msgs
  end
end

transition Approve (spender : ByStr20, tokens : Uint128)
  al <- allowed;
  sender_map = builtin get al _sender;
  match sender_map with
  | Some m =>
    allowed_to_spender = builtin put m spender tokens;
    allowed_new = builtin put al _sender allowed_to_spender;
    allowed := allowed_new;
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; status : True };
    msgs = one_msg msg;
    send msgs
  | None =>
    allowed_to_spender = let m = Emp ByStr20 Uint128 in builtin put m spender tokens;
    allowed_new = builtin put al _sender allowed_to_spender;
    allowed := allowed_new;
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; status : False };
    msgs = one_msg msg;
    send msgs
  end
end

transition Allowance (tokenOwner : ByStr20, spender : ByStr20)
  al <- allowed;
  towner_map = builtin get al tokenOwner;
  match towner_map with
  | Some m =>
    spender_allowance = builtin get m spender;
    match spender_allowance with
    | Some n =>
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; allowed : n };
      msgs = one_msg msg;
      send msgs
    | None =>
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; allowed : Uint128 0 };
      msgs = one_msg msg;
      send msgs
    end
  | None =>
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; allowed : Uint128 0 };
    msgs = one_msg msg;
    send msgs
  end
end
  
transition safeApprove (_spender : ByStr20 , _currentValue : Uint128 , _value : Uint128 )
  al <- allowed;
  sender_map = builtint get al _sender;
  match sender_map with 
    Some m =>
    spender_val=builting get m spender;
    equal_spender=builtint eq _currentvalue spender_value;
    match equal_spender with
      True =>
      msg = { _tag : "approve"; _recipient : _sender; _amount : Uint128 0; status : True };
      msgs = one_msg msg;
      send msgs  
      False => 
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; status : False };
      msgs = one_msg msg;
      send msgs    
    end      
    None =>
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; status : False };
    msgs = one_msg msg;
    send msgs          
  end
end

 
          

transition Transfer(to : ByStr20 , value : Uint128 )
  bl <- balances;
  bal = builtint get bl _sender;
  match bal with
    Some b =>
    can_do = lt_int value b;
    match can_do with 
      True => 
      new_sender_balance= builtin sub b value;
      new_balances = builtin put bl _sender new_sender_balance;
      to_bal = builtin get new_balances to;
      match to_bal with
      | Some x =>
        new_to_bal = builtin add x value;
        new_balances2 = builtin put new_balances to new_to_bal;
        balances := new_balances2
      | None =>
        new_balances3 = builtin put new_balances to value;
        balances := new_balances3
      end;
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : value };
      msgs = one_msg msg;
      send msgs
    | False =>
      (* balance not sufficient. *)
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 };
      msgs = one_msg msg;
      send msgs
    end
  | None =>
    (* no balance record, can't transfer *)
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 };
    msgs = one_msg msg;
    send msgs
  end
end

transition transferFrom(fromm : ByStr20 , to : ByStr20 , value : Unit128)
  al <- allowed;
  sender_map = builtin get al fromm;
  match sender_map with 
    Some m =>
    spender_val = Builtin get m _spender;
    can_do = lt_int value spender_value;
    match can_do with 
      True => 
      new_sender_balance= builtin sub spender_val value;
      new_balances = builtin put bl fromm new_sender_balance;
      to_bal = builtin get new_balances to;
      match to_bal with
      | Some x =>
        new_to_bal = builtin add x value;
        new_balances2 = builtin put new_balances to new_to_bal;
        balances := new_balances2
      | None =>
        new_balances3 = builtin put new_balances to value;
        balances := new_balances3
      end;
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : value };
      msgs = one_msg msg;
      send msgs
    | False =>
      (* balance not sufficient. *)
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 };
      msgs = one_msg msg;
      send msgs
    end
  | None =>
    (* no balance record, can't transfer *)
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 };
    msgs = one_msg msg;
    send msgs
  end
end

transition burnFrom(fromm : ByStr20 , value : Uint128 )
  bl <- balances;
  sender_val= builtin get bl fromm;
  al <- allowed;
  allowed_map=builtin get al fromm;
  match allowed_map with 
    Some m =>
    allowed_value=builtin get m _sender;
    can_do = lt_int value allowed_value;
    match can_do with
    True => 
    new_sender_balance = builtin sub sender_val value;
    new_balances = builtin put bl _sender new_sender_balance;
    balances := new_balances;
    new_allowed_balance = builtin sub allowed_val value;
    new_balances1=builtin put al fromm new_allowed_balance;
    allowed :=new_balance1;
    tot_sup=builtin sub totalSupply value;
    totalSupply := tot_sup;
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; status : True };
    msgs = one_msg msg;    

transition approveAndCAll(spender : ByStr20, value : Uint128 )
  

  
transition burn(value : Uint128)
  bl <- balances;
  sender_val= builtin get bl _sender
  can_do = lt_int value sender_val
  match can_do with
    True => 
    new_sender_balance = builtin sub sender_val value;
    new_balances = builtin put bl _sender new_sender_balance;
    balances := new_balances;
    tot_sup=builtin sub totalSupply value;
    totalSupply := tot_sup;
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; status : True };
    msgs = one_msg msg;
    send msgs
    False =>
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; status : False(bot burned) };
    msgs = one_msg msg;
    send msgs    
  end
end

































  
